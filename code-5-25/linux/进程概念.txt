	现代计算机系统一般采用多任务并发执行方式,而且有的计算机系统由多个用户同时联机使用,这使得计算机的资源不是由一个程序在运行时独占使用,而是由多个并发运行的程序共享使用.如果由各并发运行的程序自己可以同时有另一个进程在处理器上进行计算.决定如何使用资源,则会各行其事,造成冲突,混乱,使系统无法顺利高效运行,因此要有一个地位高于各应用程序之上的软件来进行自动的,统一的管理,这个软件就是操作系统.操作系统的目标之一就是统一管理分配计算机系统资源,在保证各并发执行的应用程序书里运行的前提下提高资源利用率.

单任务单用户和多任务多用户
	单处理器系统中,程序有两种运行方式:单道程序顺序执行(单任务单用户)和多道程序并发运行(多用户多任务).
	单道程序顺序执行:要执行的多个程序按一定次序依次执行,一个程序运行完毕才能运行下一个程序,既在一个程序运行期间不插入运行其他程序.这种运行方式的优点是实现简单,不需要在多个进程之间进行转换;缺点是资源利用率低,因为在系统运行的过程中,始终是一道程序独占系统全部资源,一般一道程序不会同时进行计算和输入输出操作,这使得处理器和设备串行工作,在处理器忙时,设备空闲,在设备忙时处理器空闲,并且这样的系统无法提供多用户同时联机使用方式.
	多道程序并发执行:在内存中同时存放多道程序,按一定策略调度多道程序交叉运行,形成"微观上串行,宏观上并行"的情况,使得处理器和设备可以并行工作,当某个进程输入输出操作时,
从直观上看这种方式肯定比单道程序执行方式的资源利用率高.
	在多任务多用户的系统中,多个进程交替运行,这样进程在其生存期内肯定有多种状态,至少有运行和不运行两种状态,进程的状态数量是操作系统按照一定的管理策略设置的,进程状态转换时操作系统实施进行管理的一个基本操作.操作系统使用模块提供的功能来管理进程的状态切换.

什么是进程
1，进程是程序的一次执行
2，进程是可以和别的进程并发执行的计算
3，进程就是一个程序在给定活动空间和初始条件下，在一个处理器上的执行过程
4，进程是程序在一个数据集合上的运行过程，是系统进行资源分配和调度的一个独立单位
5，进程是动态的、有生命周期的活动。内核可以创建一个进程，而最终将由内核终止该进程使其消亡

进程和程序区别
1，程序是静态的概念，本身可以作为一种软件资源长期保存，而进程是程序的一次执行过程，是动态的概念，它有从创建到消亡的过程
2，进程是一个能独立运行的单位，能与其他进程并发执行。进程是作为资源申请和调度单位存在的；通常的程序不能作为一个独立的单位而并发执行
3，程序和进程不存在一一对应的关系。一个程序可由多个进程共用。一个进程在其活动中又可顺序地执行若干个程序。一个程序运行一次，便创建了一个进程
4，各个进程在并发执行的过程中会产生相互制约的关系，造成各自前进速度的不可预测性，而程序本身是静态的，不存在这种异步特征


进程的基本状态及转换关系

                                                                           执   行   状   态-------------> 完成或撤销                                                                               
                                                                          /^ /             \
                                                       进程调度 --------- /  /-- 时间片用完  \ 等待某件事件发生
                                                                         /  /^               \ ^
                                               进程创建------------>就绪状态  -------------->阻塞状态
 				                                                   外部事件发生

 进程的3种基本状态
就绪状态：进程的外部条件满足，但因为其他进程已占用CPU，所以暂时不能运行
执行状态：外部条件满足，进程已获得CPU，其程序正在执行。
阻塞状态：进程因等待某种事件发生（如等待其他进程释放资源。等待其他进程发来的信号等）而暂时不能运行的状态称为阻塞状态，也称为等待状态。



进程的组成模型
    PCB(程序执行的过程)
   程序部分
   数据集合
PCB（process control block进程控制块）：包含一个进程的描述信息、控制信息和资源信息。描述进程当前的状态、本身的特性等


  按照功能大概分成4个组成部分：
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
   1、进程标示符：唯一地标示一个进程   PID
＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
   2、处理器状态（cpu的现场信息）：由处理器的各种寄存器（中央处理器内的组成部分。寄存器是有限存贮容量的高速存贮部件，它们可用来暂存指令、数据和位址。在中央处理器的控制部件中，包含的寄存器有指令寄存器(IR)和程序计数器(PC)。）中得内容组成
   3、进程调度信息：进程的状态；进程优先级；进程调度所需要的其他信息；时间或者阻塞的原因
   4、进程控制信息：程序和数据的地址，指进程和程序和数据所在的内存或外存的地址，以便再调度到该进程执行时，能从PCB中找到其程序和数据
                                      进程同步和通信机制，如消息队列指针，信号量，它们可能全部或者部分放在PCB中
                                    资源清单，是一张列出了除CPU意外进程所需的全部资源及已经分配 到该进程的资源的清单
                                 链接指针，给出了本进程PCB所在队列的下一个进程PCB的首地址
程序和它操作的数据是进程存在的实体，这两者是静态的。

进程的创建
1.申请一个空白的PCB。为新进程申请唯一的进程标示符，并从PCB集合中索取一个空白的PCB
2，为新进程分配资源，包括新创建进程的程序、数据、及用户栈（ 用户栈是用户进程空间中的一块区域，用于保存用户进程的子程序间相互调用的参数、返回值、返回点以及子程序(函数)的局部变量）所需的内存空间，此时系统必须知道新进程所需内存的大小。
3，初始化进程控制块
4将新建进程的PCB插入就绪态队列

进程的终止过程
1，根据被终止进程的标示符，从PCB队列中检索出该进程的PCB ，从中读出该进程的状态
2，若被终止进程正处于执行状态，应立即终止该进程的执行，该进程被终止后应重新进行进程调度
3，检查该进程有无子孙进程，若有应将其所有的子孙进程终止。
4，释放终止的进程所占有的资源，将其归还它父进程或系统
5，将被终止的进程从它的PCB队列中移出（进程没用从PCB队列中移出就行成僵尸进程）

进程分为父进程、子进程、孤儿进程、僵尸进程

linux系统调用
在linux系统中，系统向用户提供了一些对进程进行控制的系统调用
fork()系统调用
linux利用fork()系统调用创建一个新进程；fork()是用过复制父进程来创建子进程的，子进程继承父进程的上下文，是父进程的一个副本，与父进程使用同一段代码，在被该系统调用之后，两个代码相同的进程并发执行；fork()系统调用出错可能基于两方面的原因：1.当前进程数量已经达到系统规定的最大值，2，系统内存不足

exec()系统调用
fork()系统调用创建的子进程和父进程执行的是同一段代码，但实际上，它们完成不同的工作。linux系统中，当由fork()系统调用创建一个子进程后，可再利用exec()系统调用执行另一个程序

exit()系统调用
对于一般的用户进程而言，在其任务完成后应被尽快撤销。linux系统用exit()系统调用来实现进程的自我终止，通常，父进程在创建子进程时，应在进程的末尾编写exit()系统调用，使子进程自我终止。


Linux系统进程管理
pstree  查看系统所有进程
ps aux  ef
 a 显示终端上的所有进程，包括其他用户的进程。
 A 显示所有程序
 x 显示没有控制终端的进程。
 u 选项来查看进程所有者及其他一些详细信息
    ps ax 所有进程，“？”表示没有在终端上 启动的进程。
 e 此参数的效果和指定“A”参数相同
 f 用ASCII字符显示树状结构，表达程序间的相互关系


ps aux   指令每一列的含义
USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND 
USER: 进程拥有者 
PID: pid 进程标识符
%CPU: 占用的 CPU 使用率 
%MEM: 占用的记忆体使用率 
VSZ: 占用的虚拟记忆体大小，  预分配内存
RSS: 占用的记忆体大小   ， 实际占用的内存
TTY: 终端的次要装置号码 (minor device number of tty) 
STAT: 该行程的状态: 
      D: 不可中断的静止
      R: 正在执行中 
      S: 静止状态 
      T: 暂停执行 
      Z: 不存在但暂时无法消除 
      W: 没有足够的记忆体分页可分配 
               <: 高优先序的行程 
      N: 低优先序的行程 
      L: 有记忆体分页分配并锁在记忆体内 (即时系统或捱A I/O) 
START: 行程开始时间 
TIME: 执行的时间 
COMMAND:所执行的指令 


linux上进程有5种状态: 
1. 运行(正在运行或在运行队列中等待) 
2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) 
3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) 
4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) 
5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) 

ps工具标识进程的5种状态码: 
D 不可中断 uninterruptible sleep (usually IO) 
R 运行 runnable (on run queue) 
S 中断 sleeping 
T 停止 traced or stopped 
Z 僵死 a defunct (”zombie”) proce

top＊＊＊（要求对列进行排序，按f键进入调整界面，每一列前都有对应的字母，大写表示已开启，小写表示已关闭，初始界面按W，保存到指定文件／root/.toprc）
top命令是Linux系统管理的一个主要命令，通过它可以获得许多信息。这里我们结合图1来说明它给出的信息。 

　　第一行表示的项目依次为当前时间、系统运行时间、当前系统登录用户数目、1/5/10分钟系统平均负载(一般来说，这个负载值应该不太可能超过 1 才对，除非您的系统很忙碌。 如果持续高于 5 的话，那么.....仔细的看看到底是那个程序在影响整体系统吧！)。 

　　第二行显示的是所有启动的进程、目前运行、挂起 (Sleeping)的和无用(Zombie)的进程。(比较需要注意的是最后的 zombie 那个数值，如果不是 0 ，嘿嘿！好好看看到底是那个 process 变成疆尸了吧？！)(stop模式：与sleep进程应区别，sleep会主动放弃cpu，而stop是被动放弃cpu ，例单步跟踪，stop（暂停）的进程是无法自己回到运行状态的) 

　　第三行显示的是目前CPU的使用情况，包括us用户空间占用CPU百分比、sy 内核空间占用CPU百分比、ni 用户进程空间内改变过优先级的进程占用CPU百分比(中断处理占用)、id 空闲CPU百分比、wa 等待输入输出的CPU时间百分比、hi,si,st 三者的意思目录还不清楚 ：) 

　　第四行显示物理内存的使用情况，包括总的可以使用的内存、已用内存、空闲内存、缓冲区占用的内存。 

　　第五行显示交换分区使用情况，包括总的交换分区、使用的、空闲的和用于高速缓存的大小。 

　　第六行显示的项目最多，下面列出了详细解释。
 
top指令各列含义
　　PID（Process ID）：进程标示号 ( 每个 process 的 ID ) 

　　USER：进程所有者的用户名 ( 该 process 所属的使用者 ) 

　　PR：进程的优先级别 ( Priority 的简写，程序的优先执行顺序，越小越早被执行 ) 

　　NI：进程的优先级别数值 ( Nice 的简写，与 Priority 有关，也是越小越早被执行 ) 

　　VIRT：进程占用的虚拟内存值。 

　　RES：进程占用的物理内存值。 

　　SHR：进程使用的共享内存值。 

　　S：进程的状态，其中S表示休眠，R表示正在运行，Z表示僵死状态，N表示该进程优先值是负数。 

　　%CPU：该进程占用的CPU使用率。 

　　%MEM：该进程占用的物理内存和总内存的百分比。 

　　TIME＋：该进程启动后占用的总的CPU时间 ( CPU 使用时间的累加 ) 

　　Command：进程启动的启动命令名称，如果这一行显示不下，进程会有一个完整的命令行。 

　　top命令使用过程中，还可以使用一些交互的命令来完成其它参数的功能。这些命令是通过快捷键启动的。 

　　＜空格＞：立刻刷新。 

　　P：根据CPU使用大小进行排序。 

　　T：根据时间、累计时间排序。 

　　q：退出top命令。 

　　m：切换显示内存信息。 

　　t：切换显示进程和CPU状态信息。 

　　c：切换显示命令名称和完整命令行。 

　　M：根据使用内存大小进行排序。 

　　W：将当前设置写入~/.toprc文件中。这是写top配置文件的推荐方法。 

　　可以看到，top命令是一个功能十分强大的监控系统的工具，对于系统管理员而言尤其重要。但是，它的缺点是会消耗很多系统资源。 

　　应用实例 

　　使用top命令可以监视指定用户，缺省情况是监视所有用户的进程。如果想查看指定用户的情况，在终端中按“U”键，然后输入用户名，系统就会切换为指定用户的进程运行界面。 


/proc目录简单介绍
proc文件系统是一个伪文件系统，它只存在内存当中。它以文件系统的方式为访问系统内核数据的操作提供接口。用户和应用程序可以通过proc得到系统的信息，并可以改变内核的某些参数。
proc 文件系统可以被用于收集有用的关于系统和运行中的内核的信息。下面是一些重要的文件：
* /proc/cpuinfo - CPU 的信息 (型号, 家族, 缓存大小等) 
* /proc/meminfo - 物理内存、交换空间等的信息 
* /proc/mounts - 已加载的文件系统的列表 
* /proc/devices - 可用设备的列表 
* /proc/filesystems - 被支持的文件系统 
* /proc/modules - 已加载的模块 
* /proc/version - 内核版本 
* /proc/cmdline - 系统启动时输入的内核命令行参数 

/proc/pid
environ 进程使用的环境变量信息。
mounts 文件内容是当前进程加载的文件系统。
root 链接此进程的root目录
Stat 进程状态。
exe 符号链接，指向进程的可执行文件
mem 进程的内存被利用情况476 。
fd 包含当前进程所有文件描述符的目录。
该目录下会发现1,2,3是被系统霸占的：
0 C 标准输入（standard input）；1 C 标准输出（standard output）；2 C 标准错误（standard error）。从3开始系统自动分配给应用程序使用。若进程使用大量文件句柄（如TCP服务器），要特别关注这个目录下的句柄增长情况。系统默认最大允许使用1024个句柄，文件句柄用完之后就会提示错误”too many open files”。一般来说是出现了文件句柄泄漏，使用完之后没有close。如果需要更改最大句柄使用限制，使用ulimic -n命令，如：ulimit -n 10240，从经验上来讲，对于提供tcp服务的进程，该设置是十分必要的。
mapped_base 该文件内容是一个地址，共享库将从该地址装载到内存。看到的内容是”1073741824″，转换成十六进制就是0×40000000，这就是默认值。可以把这个值设置低一些，留更多的内存给应用程序。DB2或Oracle安装有修改这个值的，让更多内存留给数据库共享内存使用，这样就有超过 2GB 的空间留给数据库共享内存。
status 进程当前状态，State，PID，UID，PPID等信息。这些信息可通过ps或top看到。
task 该目录列出了进程中所有线程（包括主线程）。每个线程目录下也有自己的fd等目录和文件。





meminfo
 MemTotal: 所有可用RAM大小 （即物理内存减去一些预留位和内核的二进制代码大小）

     MemFree: LowFree与HighFree的总和，被系统留着未使用的内存

     Buffers: 用来给文件做缓冲大小

     Cached: 被高速缓冲存储器（cache memory）用的内存的大小（等于 diskcache minus SwapCache ）.

  SwapCached:被高速缓冲存储器（cache memory）用的交换空间的大小
             已经被交换出来的内存，但仍然被存放在swapfile中。用来在需要的时候很快的被替换而不需要再次打开I/O端口。

     Active: 在活跃使用中的缓冲或高速缓冲存储器页面文件的大小，除非非常必要否则不会被移作他用.

    Inactive: 在不经常使用中的缓冲或高速缓冲存储器页面文件的大小，可能被用于其他途径.

   HighTotal:
   HighFree: 该区域不是直接映射到内核空间。内核必须使用不同的手法使用该段内存。

    LowTotal:
    LowFree: 低位可以达到高位内存一样的作用，而且它还能够被内核用来记录一些自己的数据结构
          
   SwapTotal: 交换空间的总大小

    SwapFree: 未被使用交换空间的大小

    Dirty: 等待被写回到磁盘的内存大小。
      
   Writeback: 正在被写回到磁盘的内存大小。
   
   AnonPages：未映射页的内存大小
   
   Mapped: 设备和文件等映射的大小。
   
   Slab: 内核数据结构缓存的大小，可以减少申请和释放内存带来的消耗。

   SReclaimable:可收回Slab的大小
   
   SUnreclaim：不可收回Slab的大小（SUnreclaim+SReclaimable＝Slab）
   
   PageTables：管理内存分页页面的索引表的大小。
   
   NFS_Unstable:不稳定页表的大小
  

VmallocTotal: 可以vmalloc虚拟内存大小

VmallocUsed: 已经被使用的虚拟内存大小。


free   查看内存
-b 　以Byte为单位显示内存使用情况。
-k 　以KB为单位显示内存使用情况。
-m 　以MB为单位显示内存使用情况。
-o 　不显示缓冲区调节列。
-s<间隔秒数> 　持续观察内存使用状况。
-t 　显示内存总和列。
-V 　显示版本信息。




free -m
   total       used       free     shared    buffers     cached
Mem:         1002        769        232          0         62        421
-/+ buffers/cache:        286        715
Swap:         1153          0       1153
第二行(mem)：
total:总计物理内存的大小。
used:已使用多大。
free:可用有多少。
Shared:多个进程共享的内存总额。
Buffers/cached:磁盘缓存的大小。
  cached：数据缓存       buffers：索引缓存
第三行(-/+ buffers/cached):
used:已使用多大。
free:可用有多少。
第二部分(-/+ buffers/cache):
(-buffers/cache) used内存数：286 (指的第一部分Mem行中的used C buffers C cached)
(+buffers/cache) free内存数: 715M (指的第一部分Mem行中的free + buffers + cached)

可见-buffers/cache反映的是被程序实实在在吃掉的内存，而+buffers/cache反映的是可以挪用的内存总数。

第三部分是指交换分区, 

.第一部分(Mem)与第二部分(-/+ buffers/cache)的结果中有关used和free为什么这么奇怪.
对操作系统来讲是Mem的参数.buffers/cached 都是属于被使用,所以它认为free只有232.
对应用程序来讲是(-/+ buffers/cach).buffers/cached 是等同可用的，因为buffer/cached是为了提高程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。



＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊＊
man 7 signal
Signal 15, TERM (default) - Terminate cleanly  整洁管理
Signal 9, KILL - Terminate immediately    强行关闭
Signal 1, HUP - Re-read configuration files   重新加载配置文件



kill  把signal给进程，默认signal 为 15
kill [signal] PID  
killall [signal] command




nice renice    -20~19   －20  优先级越高，19  优先级最低   默认为  0  
When starting a process:
nice -n 5 command  指定指令运行时的有限级
After starting:
 renice 5 PID  将PID的权限设为  5
普通用户只能把优先级调低，不能调高





作业控制
LINUX中的前台任务和后台任务，应该就是前台进程和后台进程 
前台进程是属于某一个终端的进程，如果使用这个终端的退出了终端那么这个进程就会被kill掉，后台进程是独立于任何终端的进程，除非是进程自己退出（包括正常和非正常）或者被其他进程和手工kill掉，后台进程会一直运行到关机。
jobs 查看后台运行的程序    第一列中括号中的数字为作业号，对后台进程操作时必须要加“％”，否则所作的操作是对前台所对应的PID号的进程操作的，而不是后台进程。
kill  ％<作业号>  结束模个进程
bg  ％<作业号> 恢复后台运行的进程，在后台处于挂起状态的进程，变为后台运行状态，与前台没有关系。
fg   ％<作业号> 恢复前台运行的进程
^Z
%的使用




高级计划任务管理维护系统（at，cron，anacron）
at
时间定义方式

at服务：
at队列：用来存储尚未执行的任务，一旦执行了就从队列中将任务删除，队列的保存位置/var/spool/at/
at服务：用来检测和执行任务，每间隔1一分钟就会检查队列中是否有到时的任务。
at工具：用来添加、查看、删除定时任务的工具
at服务的启动和停止：#service atd restart
at 参数：-l  查看任务列队    -d  删除任务

建立任务：
#at 18:00
HH:MM YYYY-MM-DD
#at 18:00 2011-03-04
HH:MM[am|pm] [Month] [Date]
#at 06pm May 15
HH:MM[am|pm] + number [minutes|hours|days|weeks]
#at now + 5 min
查看任务：#at -l
任务存储位置：/var/spool/at/
查看任务内容：#at -c 4

at的控制方法：
/etc/at.allow    /etc/at.deny
1. 先查看.allow，后查看.deny。
2. 找到匹配的就不再继续看后面的文件。
3. 如果都没有匹配，默认允许访问。
4. 没有这个文件，只有root可以

cron

crontab  可以循环执行
crontab -e -u -l -d
/etc/cron.deny
/var/spool/cron目录的作用
时间定义格式
系统计划任务/etc/crontab
/etc/cron.hourly
/etc/cron.daily
/etc/cron.weekly
/etc/cron.monthly
anacron
/etc/anacorntab解释




Linux日志机制
日志syslog 
syslogd
klogd
/etc/syslog.conf
man 5 syslog.conf
日志对象
日志级别
　info: 一些提示信息资料；

　　notice: 需要您注意的信息；

　　warn或者waring： 警告信息；

　上面三个信息虽然是提醒您注意，但是却还没有到错误的情况。下面的信息就要注意了。[/color]

　　error或者err: 错误信息。您需要仔细检查发生错误的原因了；

　　crit： 很严重的错误，到达临界点了；

　　alert: 警告！ 是否想起了“Red Alert”?不过，在这里这可是相当严重的错误啊；

　　emerg或者panic：系统混乱，重做吧；

　　特别的：

　　debug: 将显示很多信息；

　　none: 顾名思义，什么信息也不记录。


日志记录文件
日志集中管理（日志远程记录）
高级日志管理（logrotate）
什么是logrotate

　　logrotate是对日志文件做轮换。就是把现在的log命名为log.1，然后继续写log。如果存在log.1就命名log.1为log.2然后命名log为log.1，依此类推，但并非没有尽头。这个尽头就是您在logrotate的配置文件中的定义，系统默认的是到4。那么对log.4做什么操作呢？删除。

　　syslogd是daemons方式运行的；

　　logrotate是按计划运行的。


日志轮转管理的意义
/etc/logrotate.conf
logrotate 配置 


logrotate 程序是一个日志文件管理工具。用来把旧的日志文件删除，并创建新的日志文件，我们把它叫做“转储”。我们可以根据日志文件的大小，也可以根据其天数来转储，这个过程一般通过 cron 程序来执行。 

logrotate 程序还可以用于压缩日志文件，以及发送日志到指定的E-mail 。 


logrotate 的配置文件是 /etc/logrotate.conf。主要参数如下表： 


参数 功能 

compress 通过gzip 压缩转储以后的日志 

nocompress 不需要压缩时，用这个参数 

copytruncate 用于还在打开中的日志文件，把当前日志备份并截断 

nocopytruncate 备份日志文件但是不截断 

create mode owner group 转储文件，使用指定的文件模式创建新的日志文件 

nocreate 不建立新的日志文件 

delaycompress 和 compress 一起使用时，转储的日志文件到下一次转储时才压缩 

nodelaycompress 覆盖 delaycompress 选项，转储同时压缩。 

errors address 专储时的错误信息发送到指定的Email 地址 

ifempty 即使是空文件也转储，这个是 logrotate 的缺省选项。 

notifempty 如果是空文件的话，不转储 

mail address 把转储的日志文件发送到指定的E-mail 地址 

nomail 转储时不发送日志文件 

olddir directory 转储后的日志文件放入指定的目录，必须和当前日志文件在同一个文件系统 

noolddir 转储后的日志文件和当前日志文件放在同一个目录下 

prerotate/endscript 在转储以前需要执行的命令可以放入这个对，这两个关键字必须单独成行 

postrotate/endscript 在转储以后需要执行的命令可以放入这个对，这两个关键字必须单独成行 

daily 指定转储周期为每天 

weekly 指定转储周期为每周 

monthly 指定转储周期为每月 

rotate count 指定日志文件删除之前转储的次数，0 指没有备份，5 指保留5 个备份 

tabootext [+] list 让logrotate 不转储指定扩展名的文件，缺省的扩展名是：.rpm-orig, .rpmsave, v, 和 ~ 

size size 当日志文件到达指定的大小时才转储，Size 可以指定 bytes (缺省)以及KB (sizek)或者MB (sizem). 

